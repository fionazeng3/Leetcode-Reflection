/*
LIN 598 Zombie in Matrix
åšåˆ°è¿™é‡Œbfs å·²ç»éå¸¸ç®€å•äº†ã€‚ è¿™é“é¢˜åŸºæœ¬
å’Œ walls and gates ä¸€æ¨¡ä¸€æ ·ã€‚ é¦–å…ˆæŠŠğŸ§Ÿâ€â™€ï¸
ä½ç½®å­˜åˆ°queue é‡Œã€‚ç„¶åå†ç”¨bfs æ¯åªåƒµå°¸è½®æµ
å’¬äººã€‚ æœ€åå†ç”¨ä¸ªfor loop æ£€æŸ¥ä¸€ä¸‹æœ€ç»ˆæƒ…å†µå°±å¥½äº†
æ³¨æ„è¿™é‡Œæœ‰ä¸ªå¾ˆtricky çš„corner caseï¼Œ å°±æ˜¯
é—¨çš„å€¼æ˜¯2ï¼Œå¯èƒ½ä¼šå½±å“åˆ°æœ€åä¸€æ­¥æ‰¾æœ€å¤§çš„step
æ‰€ä»¥åœ¨ç¬¬ä¸€æ¬¡traversal çš„æ—¶å€™æŠŠé—¨éƒ½å˜æˆ-1 å°±è¡Œäº†
*/
public class Solution {
    /**
     * @param grid: a 2D integer grid
     * @return: an integer
     */
    public int zombie(int[][] grid) {
        // write your code here
        if(grid.length == 0) return -1;
        int y = grid.length;
        int x = grid[0].length;
        int[] dx = {0,0,1,-1};
        int[] dy = {1,-1,0,0};
        Queue<Integer> qx = new LinkedList<>();
        Queue<Integer> qy = new LinkedList<>();
        // add all zombies' location in the queue
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                if(grid[j][i] == 1) {
                    qx.offer(i);
                    qy.offer(j);
                } else if (grid[j][i] == 2) {
                    grid[j][i] = -1;
                }
            }
        }
        // perform bfs on every zombie
        while(!qx.isEmpty()) {
            int cx = qx.poll();
            int cy = qy.poll();
            for (int i = 0; i < 4; i++) {
                int nx = cx + dx[i];
                int ny = cy + dy[i];
                if(nx >= 0 && nx < x && ny >= 0 && ny < y && grid[ny][nx] == 0) {
                    grid[ny][nx] = grid[cy][cx] + 1;
                    qx.offer(nx);
                    qy.offer(ny);
                }
            }
        }
        // check the result
        int maxStep = 1;
        boolean peopleFound = false;
        for (int i = 0; i < x; i++) {
            for(int j = 0; j < y; j++) {
                if(grid[j][i] == 0) {
                    peopleFound = true;
                    break;
                } else {
                    maxStep = Math.max(maxStep,grid[j][i]);
                }
            }
        }
        maxStep --;
        if(peopleFound) {
            return -1;
        } else {
            return maxStep;
        }
    }
}
