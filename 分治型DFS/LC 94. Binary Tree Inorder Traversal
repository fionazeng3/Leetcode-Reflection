/*
LC 94. Binary Tree Inorder Traversal
这道题不让用recursion 的方法做。 那就要想一想recursion的方法怎么转换成iterative
的方法。 recursion 的顺序是 left， print right
那么在iternative 的方法中， 先把最左边的node 加进stack 中。 然后while stack 非空，
处理每一个node。
如当前node 的右边非null。 那就先把右边的node 加进来， 再把他的所有左node 加进来处理
这样用stack 实现了一个left print right 的顺序
*/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Stack<TreeNode> s = new Stack<>();
       // push the left one line onto the stack
        while(root != null) {
            s.push(root);
            root = root.left;
        }
        while(!s.isEmpty()) {
            TreeNode current = s.peek();
            ans.add(current.val);
            s.pop();
            // right is not null
            if(current.right != null) {
                current = current.right;
                while(current != null) {
                    s.push(current);
                    current = current.left;
                }
             }
        }
        return ans;
    }
}
