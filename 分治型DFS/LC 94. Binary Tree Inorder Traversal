/*
LC 94. Binary Tree Inorder Traversal
这道题不让用recursion 的方法做。 那就要想一想recursion的方法怎么转换成iterative
的方法。 recursion 的顺序是 left， print right
那么在iternative 的方法中， 先把最左边的node 加进stack 中。 然后while stack 非空，
处理每一个node。
如当前node 的右边非null。 那就先把右边的node 加进来， 再把他的所有左node 加进来处理
如当前的node的右边是空的， 那么处理一下以它为右节点的父亲节点， 把这些父亲节点都pop 掉。 因为
当时加入当前节点的时候， 他们的父亲已经加入到了最终的答案里。 已经处理过了。
*/

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) return ans;
        Stack<TreeNode> s = new Stack<>();
       // push the left one line onto the stack
        while(root != null) {
            s.push(root);
            root = root.left;
        }
        while(!s.isEmpty()) {
            TreeNode current = s.peek();
            ans.add(current.val);
            // right is not null
            if(current.right != null) {
                current = current.right;
                while(current != null) {
                    s.push(current);
                    current = current.left;
                }
            // right is null
            } else {
                s.pop();
                while(!s.isEmpty() && s.peek().right == current) {
                    current = s.pop();
                }
            }
        }
        return ans;
    }
}
